{
 "id":"7505382",
 "name":"Erik Berlin",
 "screen_name":"sferik",
 "tweets":[
  {"id":"1206355030250524672","timestamp":"1576452426","retweet_count":"7","favorite_count":"73","in_reply_to_status_id":"null","in_reply_to_user_id":"null","in_reply_to_screen_name":"null","text":"this.tweet.likes.forEach(like =&gt; new Tweet({topic: \"software development at startups\"})) https://t.co/wECTDPVPG9"},
  {"id":"1206374999029882880","timestamp":"1576457187","retweet_count":"2","favorite_count":"21","in_reply_to_status_id":"1206355030250524672","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"1. At an early-stage startup, it’s better to use a small number of general tools across many systems than “the best tool for the job”. Using too many tools creates complexity and information siloing which is often unnecessary. @anmolm_"},
  {"id":"1206376917408063488","timestamp":"1576457645","retweet_count":"0","favorite_count":"18","in_reply_to_status_id":"1206374999029882880","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"2. Comments are typically a sign of bad code. It’s better to refactor code to work in a straightforward way that doesn’t require a comment than to try to explain confusing code. Also, comments can—and often do lie—when code is updated but comments are not. @iiiitsandrea"},
  {"id":"1206379236958842880","timestamp":"1576458198","retweet_count":"0","favorite_count":"14","in_reply_to_status_id":"1206376917408063488","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"3. No code is faster than no code. (This was the motto of the Merb web framework, may it rest in peace.) More generally, a simpler solution is generally better than a more complex one. @hoverbird"},
  {"id":"1206380923874430978","timestamp":"1576458600","retweet_count":"0","favorite_count":"8","in_reply_to_status_id":"1206379236958842880","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"4. Programming is about tradeoffs. Some data structures have faster insertion, others have faster access. There is no one structure that’s best for everything. A lot of programming is understanding what tradeoffs to make. Also, life. @vgr"},
  {"id":"1206382311824072704","timestamp":"1576458931","retweet_count":"2","favorite_count":"13","in_reply_to_status_id":"1206380923874430978","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"5. Statistically speaking, 10× programmers should exist. Also statistically speaking, there is a good chance that you have never met one. More of an opinion: I believe 10× performance exists but it is highly context dependent. @nbashaw"},
  {"id":"1206385547377332227","timestamp":"1576459702","retweet_count":"1","favorite_count":"15","in_reply_to_status_id":"1206382311824072704","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"6. Regression tests are more valuable than test-driven development. The best indication that code needs to be tested is that it has failed in the past. Motto for testing: “Don’t make the same mistake twice / make better mistakes tomorrow.” @homsiT"},
  {"id":"1206388766019137538","timestamp":"1576460470","retweet_count":"1","favorite_count":"16","in_reply_to_status_id":"1206385547377332227","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"7. Developers should test, deploy, and broadly be responsible for their own code. Having a separate person or team responsible for testing or deploying code leads to perverse incentives. @EricRichards22"},
  {"id":"1206390122473766912","timestamp":"1576460793","retweet_count":"0","favorite_count":"16","in_reply_to_status_id":"1206388766019137538","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"8. Programmers shouldn’t just be implementers. They should understand the business and the customer and should be generating solutions to business and customer problems, not just code. @amrith"},
  {"id":"1206392080630788097","timestamp":"1576461260","retweet_count":"0","favorite_count":"8","in_reply_to_status_id":"1206390122473766912","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"9. Programming interviews should be as similar to the job as possible. For example, candidates should be able to use their own programming environment, have access to the Internet, etc. @jhooks"},
  {"id":"1206394475561586689","timestamp":"1576461831","retweet_count":"1","favorite_count":"13","in_reply_to_status_id":"1206392080630788097","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"10. Programming is creative writing with two distinct audiences: a computer and other programmers (including your future self). Good programmers can write code optimized for one audience; great programmers can write code optimized for both. @MiichaelGill"},
  {"id":"1206396750497484801","timestamp":"1576462373","retweet_count":"1","favorite_count":"12","in_reply_to_status_id":"1206394475561586689","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"11. Great programmers are able to explain their code to anyone, at their level of understanding: at a detailed, technical level (e.g. to fellow programmers) or at a high, general level (e.g. to salespeople). @jobrodude"},
  {"id":"1206397735643029504","timestamp":"1576462608","retweet_count":"1","favorite_count":"14","in_reply_to_status_id":"1206396750497484801","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"12. Everyone at a startup—customer support, designers, product managers, salespeople—should be able to query the primary datastore. This typically means everyone should know a little SQL. @posobin"},
  {"id":"1206400045156843520","timestamp":"1576463159","retweet_count":"0","favorite_count":"2","in_reply_to_status_id":"1206397735643029504","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"13. It’s easier to update library code and other dependencies regularly than doing occasional updates across multiple versions. @QiaochuYuan"},
  {"id":"1206405877399465986","timestamp":"1576464549","retweet_count":"0","favorite_count":"14","in_reply_to_status_id":"1206400045156843520","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"14. Wait until you have at least 3 examples before creating an abstraction. If your abstract code is only being used in one or two places, it’s probably more of a concretion with indirection. @adenylll"},
  {"id":"1206406014632910848","timestamp":"1576464582","retweet_count":"2","favorite_count":"14","in_reply_to_status_id":"1206405877399465986","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"15. Daily stand-ups are unnecessary. If someone is blocked, they should communicate that proactively. I suspect stand-ups exist mostly as a managment tool to get everyone into the office by 10 AM, which is counterproductive. @andreasklinger"},
  {"id":"1206408621199888385","timestamp":"1576465203","retweet_count":"0","favorite_count":"13","in_reply_to_status_id":"1206406014632910848","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"16. If programmers don’t regularly use their software themselves, they should regularly observe people who do. @KingOfBrian"},
  {"id":"1206410390638338053","timestamp":"1576465625","retweet_count":"0","favorite_count":"7","in_reply_to_status_id":"1206408621199888385","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"17. Time estimates should be specified as a range, not a point. As the end nears, the range should tighten. @355E3B"},
  {"id":"1206411468440297472","timestamp":"1576465882","retweet_count":"0","favorite_count":"6","in_reply_to_status_id":"1206410390638338053","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"18. Corollary: Any task that is estimated to take more than a few days should be broken into smaller sub-tasks. @dyn_westner"},
  {"id":"1206414701527273475","timestamp":"1576466653","retweet_count":"0","favorite_count":"8","in_reply_to_status_id":"1206411468440297472","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"19. Every startup should have a hack week once per year. @sharifshameem"},
  {"id":"1206422803555196929","timestamp":"1576468585","retweet_count":"1","favorite_count":"10","in_reply_to_status_id":"1206414701527273475","in_reply_to_user_id":"7505382","in_reply_to_screen_name":"sferik","text":"20. Software startups should optimize programmer efficiency over machine efficiency. Efficient programmers can optimize inefficient code. Worst-case, machines are cheaper and easier to scale up. @utotranslucence"}
 ]
}
